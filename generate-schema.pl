#!/usr/bin/perl
# generate-schema.pl
#
# The Almanna ORM
# http://www.ambitionframework.org
#
# Copyright 2012-2013 Sensical, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Perl prototype to auto-generate Almanna entities.
#

use strict;
use warnings;
use Data::Dumper;
use DBI;
use Getopt::Long;

my @entities;
my $has_schema = 0;
my %options = ( user => '', password => '', schema => 'public' );
GetOptions( \%options,
	'dsn|d=s',
	'user|u=s',
	'password|p=s',
	'schema|s=s',
	'namespace|n=s',
	'spaces',
	'output|o=s',
	'noloader',
);

usage() unless ( $options{dsn} and $options{output} );

my %data_types = (
	-7 => 'bool',     # bit
	-6 => 'int',      # tinyint
	-5 => 'int64',    # bigint
	-1 => 'string',   # text
	0  => 'double',   # real
	1  => 'char',     # char
	4  => 'int',      # integer
	5  => 'int',      # smallint
	11 => 'DateTime', # timestamp
	12 => 'string',   # varchar
	16 => 'bool',     # boolean
	91 => 'string',   # date
	95 => 'DateTime', # timestamp with time zone
);

print 'Connecting to ' . $options{dsn} . "...\n";
my $dbh = DBI->connect( $options{dsn}, $options{user}, $options{password} ) or die DBI::errstr;

print "Writing entities...\n";
my @tables = $dbh->tables( '','','','TABLE' );
foreach (@tables) {
	if ( /\./ ) {
		next unless (/^$options{schema}\./);
		s/[^\.]+.//;
		$has_schema++;
	} 
	convert_table($_);
}

unless ( $options{noloader} ) {
	generate_loader();
}

$dbh->disconnect();

sub get_data_type {
	my ($column_info) = @_;

	if ( $column_info->{COLUMN_SIZE} and $column_info->{DATA_TYPE} == 1 ) {
		return $data_types{91};
	}
	my $type = $data_types{ $column_info->{DATA_TYPE} };
	unless ($type) {
		warn sprintf( 'Database type "%s" reported unknown datatype of %d.', $column_info->{TYPE_NAME}, $column_info->{DATA_TYPE} );
		return '';
	}
	return $type;
}

sub convert_table {
	my ($table_name) = @_;

	my @columns;
	my $sth_columns = $dbh->column_info( undef, ( $has_schema ? $options{schema} : undef ), $_, undef );
	while ( my $column_info = $sth_columns->fetchrow_hashref() ) {
		# warn $column_info->{DATA_TYPE} unless ( $data_types{ $column_info->{DATA_TYPE} } );
		push(
			@columns,
			{
				name => $column_info->{COLUMN_NAME},
				nullable => $column_info->{IS_NULLABLE} eq 'YES' ? 1 : 0,
				size => ( $column_info->{COLUMN_SIZE} or 0 ),
				type => $column_info->{TYPE_NAME},
				data_type => get_data_type($column_info)
			}
		);
	}
	my @primary_keys = $dbh->primary_key( undef, ( $has_schema ? $options{schema} : undef ), $table_name );

	generate_entity( $table_name, \@columns, \@primary_keys );
}

sub generate_entity {
	my ( $table_name, $columns, $primary_keys ) = @_;

	my $class_name = table_name_to_class_name($table_name);
	my @lines = (
		'/**',
		sprintf( ' * Almanna Entity for table "%s".', $table_name ),
		' * Generated by generate-schema.pl.',
		' */',
		sprintf( 'public class %s : Almanna.Entity {', $class_name ),
		sprintf( 'public override string entity_name { owned get { return "%s"; } }', $table_name ),
		columns_to_properties($columns),
		'',
		'public override void register_entity() {',
		columns_to_add_columns($columns),
		primary_key_definitions($primary_keys),
		'}',
		'}'
	);

	# Prepend namespace, if given
	if ( $options{namespace} ) {
		unshift( @lines, sprintf( 'namespace %s {', $options{namespace} ) );
		push( @lines, '}' );
	}

	# Prepend using statement
	unshift( @lines, 'using Almanna;' );

	open( my $file, '>', $options{output} . '/' . $class_name . '.vala' ) or die $!;
	my $tabs = 0;
	foreach my $line (@lines ) {
		$tabs-- if ( $line =~ /^\}/ );
		for ( my $i = 0; $i < $tabs; $i++ ) {
			print $file ( $options{spaces} ? '    ' : "\t" );
		}
		print $file $line . "\n";
		$tabs++ if ( $line =~ /\{$/ );
	}
	print $file "\n";
	close($file);

	push( @entities, $class_name );
}

sub generate_loader {
	my $class_name = 'AlmannaLoader';
	my @lines = (
		'/**',
		' * Almanna loader.',
		' * Generated by generate-schema.pl.',
		' */',
		'',
		sprintf( 'public class %s : Object,Almanna.Loader {', $class_name ),
		'public void load_entities() {',
		(
			map {
				'Repo.add_entity( typeof(' . $_ . ') );'
			} @entities
		),
		'}',
		'}'
	);

	# Prepend namespace, if given
	if ( $options{namespace} ) {
		unshift( @lines, sprintf( 'namespace %s {', $options{namespace} ) );
		push( @lines, '}' );
	}

	# Prepend using statement
	unshift( @lines, 'using Almanna;' );

	open( my $file, '>', $options{output} . '/' . $class_name . '.vala' ) or die $!;
	my $tabs = 0;
	foreach my $line (@lines ) {
		$tabs-- if ( $line =~ /^\}/ );
		for ( my $i = 0; $i < $tabs; $i++ ) {
			print $file ( $options{spaces} ? '    ' : "\t" );
		}
		print $file $line . "\n";
		$tabs++ if ( $line =~ /\{$/ );
	}
	print $file "\n";
	close($file);
}

sub primary_key_definitions {
	my ($primary_keys) = @_;

	if (@$primary_keys) {
		my $line;
		if ( scalar(@$primary_keys) > 1 ) {
			$line = sprintf(
				'set_primary_keys({ %s });',
				join( ", ", ( map { '"' . $_ . '"' } @$primary_keys ) )
			);
		} else {
			$line = sprintf( 'set_primary_key("%s");', $primary_keys->[0] );
		}
		return (
			'try {',
			$line,
			'} catch (EntityError e) {',
			'stderr.printf( "Error adding primary key to entity: %s\n", e.message );',
			'}'
		);
	}
	return;
}

sub columns_to_properties {
	my ($columns) = @_;

	my @lines;
	foreach my $column (@$columns) {
		push( @lines,
			sprintf( '%spublic %s %s { get; set; }',
				( $column->{data_type} ? '' : '// ' ),
				$column->{data_type},
				$column->{name},
			)
		);
	}
	return @lines;
}

sub columns_to_add_columns {
	my ($columns) = @_;

	my @lines;
	foreach my $column (@$columns) {
		push( @lines,
			sprintf( '%sadd_column( new Column<%s%s>.with_name_type( "%s", "%s" ) );',
				( $column->{data_type} ? '' : '// ' ),
				$column->{data_type},
				( $column->{data_type} eq 'double' ? '?' : '' ), # double/float need to be boxed
				$column->{name},
				$column->{type}
			)
		);
		my $default = wrap_default_column($column);
		if ($default) {
			push( @lines,
				sprintf( '%scolumns["%s"].default_value = %s;',
					( $column->{data_type} ? '' : '// ' ),
					$column->{name},
					$default
				)
			);
		}
		if ( $column->{size} ) {
			push( @lines,
				sprintf( '%scolumns["%s"].size = %d;',
					( $column->{data_type} ? '' : '// ' ),
					$column->{name},
					$column->{size}
				)
			);
		}
		if ( $column->{nullable} ) {
			push( @lines,
				sprintf( '%scolumns["%s"].is_nullable = true;',
					( $column->{data_type} ? '' : '// ' ),
					$column->{name},
				)
			);
		}
		if ( $column->{sequence} ) {
			push( @lines,
				sprintf( '%scolumns["%s"].is_sequenced = true;',
					( $column->{data_type} ? '' : '// ' ),
					$column->{name},
				)
			);
		}
		if ( $column->{sequence_name} ) {
			push( @lines,
				sprintf( '%scolumns["%s"].sequence_name = "%s";',
					( $column->{data_type} ? '' : '// ' ),
					$column->{name},
					'"' . $column->{sequence_name} . '"',
				)
			);
		}
		push( @lines, '' );
	}
	return @lines;
}

sub wrap_default_column {
	my ($column) = @_;

	return unless ( $column->{default} );

	if ( $column->{data_type} =~ /(int|float|boolean)/ ) {
		return $column->{default};
	}
	return '"' . $column->{default} . '"';
}

sub table_name_to_class_name {
	my ($table_name) = @_;

	return $table_name if ( $table_name =~ /[A-Z]/ );

	$table_name =~ s/_([a-z])/\U$1/g;
	return ucfirst($table_name);
}

sub usage {
	print join( "\n",
		'generate-schema.pl --dsn "<dsn>" --output </path/to/output> <options>',
		'',
		' --dsn       -d DBI DSN corresponding to schema.',
		' --user      -u Database username, if required.',
		' --password  -p Database password, if required.',
		' --schema    -s Database schema, if required. Defaults to public.',
		' --namespace -n Generate entities in the provided namespace.',
		' --output    -o Directory to output entities.',
		' --spaces       Generate the entity with 4 spaces instead of tabs.',
		' --noloader     Do not generate AlmannaLoader class.',
		'',
	);
	exit(-1);
}

1;
